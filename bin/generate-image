#!/bin/bash

# AI Image Generator
# Generates images using OpenAI GPT Image 1.5 or Google Gemini (nano-banana)

set -e

# Default values
SIZE="1024x1024"
OUTPUT=""
URL_ONLY=false
MODEL=""
PROVIDER="openai"
QUALITY="auto"
INPUT_IMAGES=()  # Array to hold input image paths
MASK=""  # Optional mask image for OpenAI edits

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Help function
show_help() {
    cat << EOF
AI Image Generator

Usage: generate-image "prompt" [options]

Options:
    -p, --provider PROVIDER  Provider to use: openai, gemini, gemini-pro, or imagen (default: openai)
    -s, --size SIZE         Image size (default: 1024x1024)
                           Options: 1024x1024, 1024x1536, 1536x1024
                           Gemini Pro also supports: 2048x2048, 2048x3072, 3072x2048
    -o, --output FILE       Output filename (default: generated-image-TIMESTAMP.png)
    -i, --input IMAGE       Input image for editing/reference (can use multiple)
                           OpenAI: up to 16 images (uses /edits endpoint)
                           Gemini Pro: up to 14 images
                           Gemini: up to 3 images
    -k, --mask MASK        Mask image for targeted edits (OpenAI only, PNG with transparency)
                           Transparent areas indicate where to edit
    -u, --url-only         Only output the URL, don't download the image (OpenAI only)
    -q, --quality QUALITY  Quality setting for OpenAI: low, high, auto (default: auto)
    -m, --model MODEL      Model to use (default varies by provider)
                           OpenAI: gpt-image-1.5 (default), gpt-image-1, gpt-image-1-mini
                           Gemini: gemini-2.5-flash-image (Nano Banana)
                           Gemini Pro: gemini-3-pro-image-preview (Nano Banana Pro)
                           Imagen: imagen-4.0-generate-001, imagen-4.0-ultra-generate-001,
                                   imagen-4.0-fast-generate-001
    -h, --help             Show this help message

Examples:
    generate-image "A sunset over mountains"
    generate-image "A red sports car" --quality high
    generate-image "Abstract art" --output artwork.png
    generate-image "A cityscape" --provider imagen
    generate-image "A cute robot" --provider gemini-pro
    generate-image "Detailed infographic" --provider gemini-pro --size 2048x2048
    generate-image "Make this more vibrant" -i input.png
    generate-image "Add a cat to the chair" -i room.png --mask chair-mask.png
    generate-image "Combine in style of first" -i style.png -i content.png

Environment:
    OPENAI_API_KEY must be set for OpenAI provider (default)
    GEMINI_API_KEY must be set for Gemini, Gemini Pro, and Imagen providers

Providers:
    openai     - OpenAI's GPT Image 1.5 (default, best quality, up to 16 input images)
    gemini-pro - Google's Gemini 3 Pro Image / Nano Banana Pro (up to 14 input images)
    gemini     - Google's Gemini 2.5 Flash Image / Nano Banana (up to 3 input images)
    imagen     - Google's Imagen 4.0 (generation only, no input images)

EOF
}

# Parse arguments
if [ $# -eq 0 ]; then
    show_help
    exit 0
fi

# Check if first argument is help
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    show_help
    exit 0
fi

PROMPT="$1"
shift

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -p|--provider)
            PROVIDER="$2"
            shift 2
            ;;
        -s|--size)
            SIZE="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT="$2"
            shift 2
            ;;
        -u|--url-only)
            URL_ONLY=true
            shift
            ;;
        -i|--input)
            INPUT_IMAGES+=("$2")
            shift 2
            ;;
        -k|--mask)
            MASK="$2"
            shift 2
            ;;
        -q|--quality)
            QUALITY="$2"
            shift 2
            ;;
        -m|--model)
            MODEL="$2"
            shift 2
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            show_help
            exit 1
            ;;
    esac
done

# Validate provider
if [[ ! "$PROVIDER" =~ ^(openai|gemini|gemini-pro|imagen)$ ]]; then
    echo -e "${RED}Error: Invalid provider. Must be 'openai', 'gemini', 'gemini-pro', or 'imagen'${NC}"
    exit 1
fi

# Check for API keys and set defaults based on provider
if [ "$PROVIDER" = "openai" ]; then
    if [ -z "$OPENAI_API_KEY" ]; then
        echo -e "${RED}Error: OPENAI_API_KEY environment variable is not set${NC}"
        echo "Please set it with: export OPENAI_API_KEY='your-key-here'"
        exit 1
    fi
    # Set default model for OpenAI if not specified
    if [ -z "$MODEL" ]; then
        MODEL="gpt-image-1.5"
    fi
    # Validate quality parameter
    if [[ ! "$QUALITY" =~ ^(low|high|auto)$ ]]; then
        echo -e "${RED}Error: Invalid quality. Must be 'low', 'high', or 'auto'${NC}"
        exit 1
    fi
elif [ "$PROVIDER" = "gemini" ]; then
    if [ -z "$GEMINI_API_KEY" ]; then
        echo -e "${RED}Error: GEMINI_API_KEY environment variable is not set${NC}"
        echo "Please set it with: export GEMINI_API_KEY='your-key-here'"
        exit 1
    fi
    # Set default model for Gemini if not specified
    if [ -z "$MODEL" ]; then
        MODEL="gemini-2.5-flash-image"
    fi
elif [ "$PROVIDER" = "gemini-pro" ]; then
    if [ -z "$GEMINI_API_KEY" ]; then
        echo -e "${RED}Error: GEMINI_API_KEY environment variable is not set${NC}"
        echo "Please set it with: export GEMINI_API_KEY='your-key-here'"
        exit 1
    fi
    # Set default model for Gemini Pro (Nano Banana Pro) if not specified
    if [ -z "$MODEL" ]; then
        MODEL="gemini-3-pro-image-preview"
    fi
elif [ "$PROVIDER" = "imagen" ]; then
    if [ -z "$GEMINI_API_KEY" ]; then
        echo -e "${RED}Error: GEMINI_API_KEY environment variable is not set for Imagen${NC}"
        echo "Please set it with: export GEMINI_API_KEY='your-key-here'"
        exit 1
    fi
    # Set default model for Imagen if not specified
    if [ -z "$MODEL" ]; then
        MODEL="imagen-4.0-generate-001"
    fi
    # Validate Imagen model
    if [[ ! "$MODEL" =~ ^imagen-4\.0-(generate|ultra-generate|fast-generate)-001$ ]]; then
        echo -e "${YELLOW}Warning: Non-standard Imagen model specified: $MODEL${NC}"
    fi
fi

# Validate size
if [ "$PROVIDER" = "gemini-pro" ]; then
    if [[ ! "$SIZE" =~ ^(1024x1024|1024x1536|1536x1024|2048x2048|2048x3072|3072x2048)$ ]]; then
        echo -e "${RED}Error: Invalid size for Gemini Pro. Must be 1024x1024, 1024x1536, 1536x1024, 2048x2048, 2048x3072, or 3072x2048${NC}"
        exit 1
    fi
else
    if [[ ! "$SIZE" =~ ^(1024x1024|1024x1536|1536x1024)$ ]]; then
        echo -e "${RED}Error: Invalid size. Must be 1024x1024, 1024x1536, or 1536x1024${NC}"
        exit 1
    fi
fi

# Set output filename if not specified
if [ -z "$OUTPUT" ]; then
    OUTPUT="generated-image-$(date +%s).png"
fi

# Create temporary file for response
RESPONSE_FILE=$(mktemp)
trap "rm -f $RESPONSE_FILE" EXIT

# Make API request
echo -e "${YELLOW}Generating image with prompt: \"$PROMPT\"${NC}"
echo -e "${YELLOW}Provider: $PROVIDER, Size: $SIZE, Model: $MODEL${NC}"

if [ "$PROVIDER" = "openai" ]; then
    if [ ${#INPUT_IMAGES[@]} -eq 0 ]; then
        # No input images - use generations endpoint (JSON)
        # Use jq to properly escape the prompt for JSON (handles newlines, quotes, etc.)
        JSON_PAYLOAD=$(jq -n \
          --arg model "$MODEL" \
          --arg prompt "$PROMPT" \
          --arg size "$SIZE" \
          --arg quality "$QUALITY" \
          '{model: $model, prompt: $prompt, n: 1, size: $size, quality: $quality}')

        HTTP_CODE=$(curl -s -w "%{http_code}" -o "$RESPONSE_FILE" \
          --max-time 120 \
          -X POST https://api.openai.com/v1/images/generations \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $OPENAI_API_KEY" \
          -d "$JSON_PAYLOAD")
    else
        # Has input images - use edits endpoint (multipart/form-data)
        echo -e "${YELLOW}Using edits endpoint with ${#INPUT_IMAGES[@]} input image(s)...${NC}"

        # Build curl command with image array
        CURL_CMD=(curl -s -w "%{http_code}" -o "$RESPONSE_FILE" --max-time 180 \
          -X POST "https://api.openai.com/v1/images/edits" \
          -H "Authorization: Bearer $OPENAI_API_KEY" \
          -F "model=$MODEL" \
          -F "prompt=$PROMPT" \
          -F "size=$SIZE" \
          -F "quality=$QUALITY")

        # Add each input image
        for img in "${INPUT_IMAGES[@]}"; do
            if [ ! -f "$img" ]; then
                echo -e "${RED}Error: Input image not found: $img${NC}"
                exit 1
            fi
            CURL_CMD+=(-F "image[]=@$img")
        done

        # Add mask if provided
        if [ -n "$MASK" ]; then
            if [ ! -f "$MASK" ]; then
                echo -e "${RED}Error: Mask image not found: $MASK${NC}"
                exit 1
            fi
            echo -e "${YELLOW}Including mask: $MASK${NC}"
            CURL_CMD+=(-F "mask=@$MASK")
        fi

        # Execute the curl command
        HTTP_CODE=$("${CURL_CMD[@]}")
    fi
elif [ "$PROVIDER" = "gemini" ] || [ "$PROVIDER" = "gemini-pro" ]; then
    # Create temporary JSON file for Gemini request
    REQUEST_FILE=$(mktemp)

    # Build the parts array with text prompt and optional input images
    if [ ${#INPUT_IMAGES[@]} -eq 0 ]; then
        # No input images - simple text-only request
        # Use jq to properly escape the prompt for JSON (handles newlines, quotes, etc.)
        jq -n --arg prompt "$PROMPT" \
          '{contents: [{parts: [{text: $prompt}]}]}' > "$REQUEST_FILE"
    else
        # Has input images - build request with images using Python
        echo -e "${YELLOW}Including ${#INPUT_IMAGES[@]} input image(s)...${NC}"
        python3 << PYEOF
import json
import base64
import sys

parts = [{"text": "$PROMPT"}]

input_images = """${INPUT_IMAGES[*]}""".split()
for img_path in input_images:
    try:
        with open(img_path, 'rb') as f:
            img_data = base64.b64encode(f.read()).decode('utf-8')
        # Detect mime type
        if img_path.lower().endswith('.png'):
            mime = 'image/png'
        elif img_path.lower().endswith(('.jpg', '.jpeg')):
            mime = 'image/jpeg'
        elif img_path.lower().endswith('.webp'):
            mime = 'image/webp'
        elif img_path.lower().endswith('.gif'):
            mime = 'image/gif'
        else:
            mime = 'image/png'  # default
        parts.append({
            "inline_data": {
                "mime_type": mime,
                "data": img_data
            }
        })
        print(f"Added image: {img_path}", file=sys.stderr)
    except Exception as e:
        print(f"Error loading {img_path}: {e}", file=sys.stderr)
        sys.exit(1)

request = {"contents": [{"parts": parts}]}
with open("$REQUEST_FILE", 'w') as f:
    json.dump(request, f)
PYEOF
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to process input images${NC}"
            exit 1
        fi
    fi

    # Gemini API request (works for both gemini and gemini-pro)
    HTTP_CODE=$(curl -s -w "%{http_code}" -o "$RESPONSE_FILE" \
      --max-time 120 \
      -X POST "https://generativelanguage.googleapis.com/v1beta/models/$MODEL:generateContent" \
      -H "Content-Type: application/json" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -d @"$REQUEST_FILE")

    rm -f "$REQUEST_FILE"
elif [ "$PROVIDER" = "imagen" ]; then
    # Create temporary JSON file for Imagen request
    # Use jq to properly escape the prompt for JSON (handles newlines, quotes, etc.)
    REQUEST_FILE=$(mktemp)
    jq -n --arg prompt "$PROMPT" \
      '{instances: [{prompt: $prompt}], parameters: {sampleCount: 1}}' > "$REQUEST_FILE"

    # Imagen API request (via Gemini API)
    HTTP_CODE=$(curl -s -w "%{http_code}" -o "$RESPONSE_FILE" \
      --max-time 60 \
      -X POST "https://generativelanguage.googleapis.com/v1beta/models/$MODEL:predict" \
      -H "Content-Type: application/json" \
      -H "x-goog-api-key: $GEMINI_API_KEY" \
      -d @"$REQUEST_FILE")

    rm -f "$REQUEST_FILE"
fi

# Check HTTP status
if [ "$HTTP_CODE" -ne 200 ]; then
    echo -e "${RED}Error: API request failed with status $HTTP_CODE${NC}"
    echo "Response:"
    cat "$RESPONSE_FILE"
    exit 1
fi

# Check for API errors in response
if grep -q '"error"' "$RESPONSE_FILE"; then
    echo -e "${RED}API Error:${NC}"
    cat "$RESPONSE_FILE" | python3 -m json.tool 2>/dev/null || cat "$RESPONSE_FILE"
    exit 1
fi

# Extract URL or base64 data based on provider
if [ "$PROVIDER" = "openai" ]; then
    # OpenAI response handling
    if grep -q '"url"' "$RESPONSE_FILE"; then
        # URL response format
        IMAGE_URL=$(cat "$RESPONSE_FILE" | python3 -c "import json,sys; print(json.load(sys.stdin)['data'][0]['url'])")

        if [ "$URL_ONLY" = true ]; then
            echo "$IMAGE_URL"
        else
            echo -e "${YELLOW}Downloading image...${NC}"
            curl -s "$IMAGE_URL" -o "$OUTPUT"
            echo -e "${GREEN}✅ Image saved as: $OUTPUT${NC}"
        fi
    elif grep -q '"b64_json"' "$RESPONSE_FILE"; then
        # Base64 response format
        if [ "$URL_ONLY" = true ]; then
            echo -e "${YELLOW}Note: Image was returned as base64, not a URL${NC}"
        fi

        # Extract and save base64 image
        python3 -c "
import json
import base64
import sys

with open('$RESPONSE_FILE', 'r') as f:
    response = json.load(f)

base64_image = response['data'][0]['b64_json']
image_data = base64.b64decode(base64_image)

with open('$OUTPUT', 'wb') as img_file:
    img_file.write(image_data)
"
        echo -e "${GREEN}✅ Image saved as: $OUTPUT${NC}"
    else
        echo -e "${RED}Error: Unexpected response format${NC}"
        cat "$RESPONSE_FILE"
        exit 1
    fi
elif [ "$PROVIDER" = "gemini" ] || [ "$PROVIDER" = "gemini-pro" ]; then
    # Gemini response handling (same for both gemini and gemini-pro)
    if [ "$URL_ONLY" = true ]; then
        echo -e "${YELLOW}Note: Gemini returns base64 data, not URLs${NC}"
    fi

    # Extract and save base64 image from Gemini response
    python3 -c "
import json
import base64
import sys

try:
    with open('$RESPONSE_FILE', 'r') as f:
        response = json.load(f)

    # Gemini returns image in candidates[0].content.parts - find the part with inlineData
    parts = response['candidates'][0]['content']['parts']
    base64_image = None
    for part in parts:
        if 'inlineData' in part:
            base64_image = part['inlineData']['data']
            break

    if base64_image is None:
        raise KeyError('No inlineData found in response')

    image_data = base64.b64decode(base64_image)

    with open('$OUTPUT', 'wb') as img_file:
        img_file.write(image_data)
except (KeyError, IndexError) as e:
    print(f'Error extracting image from Gemini response: {e}', file=sys.stderr)
    with open('$RESPONSE_FILE', 'r') as f:
        print(f.read(), file=sys.stderr)
    sys.exit(1)
"
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✅ Image saved as: $OUTPUT${NC}"
    else
        echo -e "${RED}Error: Failed to extract image from Gemini response${NC}"
        exit 1
    fi
elif [ "$PROVIDER" = "imagen" ]; then
    # Imagen response handling
    if [ "$URL_ONLY" = true ]; then
        echo -e "${YELLOW}Note: Imagen returns base64 data, not URLs${NC}"
    fi

    # Extract and save base64 image from Imagen response
    python3 -c "
import json
import base64
import sys

try:
    with open('$RESPONSE_FILE', 'r') as f:
        response = json.load(f)

    # Imagen returns image in predictions[0].bytesBase64Encoded
    base64_image = response['predictions'][0]['bytesBase64Encoded']
    image_data = base64.b64decode(base64_image)

    with open('$OUTPUT', 'wb') as img_file:
        img_file.write(image_data)
except (KeyError, IndexError) as e:
    print(f'Error extracting image from Imagen response: {e}', file=sys.stderr)
    with open('$RESPONSE_FILE', 'r') as f:
        print(f.read(), file=sys.stderr)
    sys.exit(1)
"
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✅ Image saved as: $OUTPUT${NC}"
    else
        echo -e "${RED}Error: Failed to extract image from Imagen response${NC}"
        exit 1
    fi
fi