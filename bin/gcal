#!/usr/bin/env python3
"""
Google Calendar CLI - Command-line interface for Google Calendar

Usage:
  gcal auth                              # Authenticate with Google
  gcal today                             # Today's events
  gcal week                              # This week's events
  gcal list --from DATE --to DATE        # List events in range
  gcal create "title" --when "time"      # Create event
  gcal update <event_id> --title "new"   # Update event
  gcal delete <event_id>                 # Delete event
  gcal freebusy DATE                     # Show free/busy for date
  gcal calendars                         # List calendars

Date formats:
  "2025-01-15"
  "tomorrow"
  "next monday"
  "2025-01-15 14:00"

Environment:
  GOOGLE_CREDENTIALS_PATH  Path to OAuth credentials JSON (default: ~/.config/google/credentials.json)
  GOOGLE_TOKEN_PATH        Path to token storage (default: ~/.config/google/token.json)
"""

import argparse
import json
import os
import sys
from datetime import datetime, timedelta, timezone
from pathlib import Path

try:
    from google.auth.transport.requests import Request
    from google.oauth2.credentials import Credentials
    from google_auth_oauthlib.flow import InstalledAppFlow
    from googleapiclient.discovery import build
    from googleapiclient.errors import HttpError
    from dateutil import parser as date_parser
    from dateutil.relativedelta import relativedelta, MO, TU, WE, TH, FR, SA, SU
except ImportError:
    print("Error: Required packages not installed", file=sys.stderr)
    print("Install with: pip install google-auth google-auth-oauthlib google-api-python-client python-dateutil", file=sys.stderr)
    sys.exit(1)

SCOPES = [
    # Gmail scopes (shared with gmail CLI)
    'https://www.googleapis.com/auth/gmail.readonly',
    'https://www.googleapis.com/auth/gmail.send',
    'https://www.googleapis.com/auth/gmail.modify',
    'https://www.googleapis.com/auth/gmail.compose',
    # Calendar scopes
    'https://www.googleapis.com/auth/calendar',
    'https://www.googleapis.com/auth/calendar.events',
]

CREDENTIALS_PATH = Path(os.environ.get('GOOGLE_CREDENTIALS_PATH', '~/.config/google/credentials.json')).expanduser()
TOKEN_PATH = Path(os.environ.get('GOOGLE_TOKEN_PATH', '~/.config/google/token.json')).expanduser()


def get_credentials():
    """Get valid credentials, prompting for auth if needed."""
    creds = None

    if TOKEN_PATH.exists():
        creds = Credentials.from_authorized_user_file(str(TOKEN_PATH), SCOPES)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            if not CREDENTIALS_PATH.exists():
                print(f"Error: Credentials file not found at {CREDENTIALS_PATH}", file=sys.stderr)
                print("Download OAuth credentials from Google Cloud Console", file=sys.stderr)
                sys.exit(1)

            flow = InstalledAppFlow.from_client_secrets_file(str(CREDENTIALS_PATH), SCOPES)
            creds = flow.run_local_server(port=0)

        TOKEN_PATH.parent.mkdir(parents=True, exist_ok=True)
        with open(TOKEN_PATH, 'w') as token:
            token.write(creds.to_json())

    return creds


def get_service():
    """Build Calendar API service."""
    creds = get_credentials()
    return build('calendar', 'v3', credentials=creds)


def parse_datetime(text):
    """Parse natural language datetime."""
    text = text.lower().strip()
    now = datetime.now()

    # Handle relative dates
    if text == 'today':
        return now.replace(hour=0, minute=0, second=0, microsecond=0)
    elif text == 'tomorrow':
        return (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    elif text == 'yesterday':
        return (now - timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    elif text.startswith('next '):
        day_map = {
            'monday': MO, 'tuesday': TU, 'wednesday': WE, 'thursday': TH,
            'friday': FR, 'saturday': SA, 'sunday': SU
        }
        day_name = text.replace('next ', '')
        if day_name in day_map:
            return now + relativedelta(weekday=day_map[day_name](+1))

    # Try parsing with dateutil
    try:
        return date_parser.parse(text, fuzzy=True)
    except Exception:
        raise ValueError(f"Could not parse date: {text}")


def format_event(event):
    """Format event for display."""
    start = event['start'].get('dateTime', event['start'].get('date'))
    end = event['end'].get('dateTime', event['end'].get('date'))

    # Parse and format times
    if 'T' in start:
        start_dt = datetime.fromisoformat(start.replace('Z', '+00:00'))
        start_str = start_dt.strftime('%Y-%m-%d %H:%M')
    else:
        start_str = start

    if 'T' in end:
        end_dt = datetime.fromisoformat(end.replace('Z', '+00:00'))
        end_str = end_dt.strftime('%H:%M')
    else:
        end_str = end

    return {
        'id': event['id'],
        'summary': event.get('summary', 'No title'),
        'start': start_str,
        'end': end_str,
        'location': event.get('location', ''),
        'description': event.get('description', ''),
        'attendees': [a.get('email') for a in event.get('attendees', [])],
        'htmlLink': event.get('htmlLink', '')
    }


def cmd_auth(args):
    """Authenticate with Google."""
    print("Authenticating with Google...")
    get_credentials()
    print("Authentication successful! Token saved to:", TOKEN_PATH)


def cmd_today(args):
    """Show today's events."""
    service = get_service()
    now = datetime.now(timezone.utc).replace(tzinfo=None)
    start_of_day = now.replace(hour=0, minute=0, second=0, microsecond=0).isoformat() + 'Z'
    end_of_day = now.replace(hour=23, minute=59, second=59, microsecond=0).isoformat() + 'Z'

    try:
        events_result = service.events().list(
            calendarId='primary',
            timeMin=start_of_day,
            timeMax=end_of_day,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        events = events_result.get('items', [])

        if not events:
            print("No events today.")
            return

        output = [format_event(e) for e in events]

        if args.json:
            print(json.dumps(output, indent=2))
        else:
            print(f"=== Today ({now.strftime('%Y-%m-%d')}) ===\n")
            for e in output:
                print(f"{e['start']} - {e['end']}: {e['summary']}")
                if e['location']:
                    print(f"  Location: {e['location']}")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_week(args):
    """Show this week's events."""
    service = get_service()
    now = datetime.now(timezone.utc).replace(tzinfo=None)
    start_of_week = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)
    end_of_week = start_of_week + timedelta(days=7)

    try:
        events_result = service.events().list(
            calendarId='primary',
            timeMin=start_of_week.isoformat() + 'Z',
            timeMax=end_of_week.isoformat() + 'Z',
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        events = events_result.get('items', [])

        if not events:
            print("No events this week.")
            return

        output = [format_event(e) for e in events]

        if args.json:
            print(json.dumps(output, indent=2))
        else:
            print(f"=== This Week ({start_of_week.strftime('%Y-%m-%d')} to {end_of_week.strftime('%Y-%m-%d')}) ===\n")
            current_date = None
            for e in output:
                event_date = e['start'].split(' ')[0] if ' ' in e['start'] else e['start']
                if event_date != current_date:
                    current_date = event_date
                    print(f"\n{current_date}:")
                time_str = e['start'].split(' ')[1] if ' ' in e['start'] else 'All day'
                print(f"  {time_str} - {e['summary']}")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_list(args):
    """List events in date range."""
    service = get_service()

    try:
        start_dt = parse_datetime(args.start)
        end_dt = parse_datetime(args.end) if args.end else start_dt + timedelta(days=1)

        events_result = service.events().list(
            calendarId='primary',
            timeMin=start_dt.isoformat() + 'Z',
            timeMax=end_dt.isoformat() + 'Z',
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        events = events_result.get('items', [])

        if not events:
            print("No events in range.")
            return

        output = [format_event(e) for e in events]

        if args.json:
            print(json.dumps(output, indent=2))
        else:
            for e in output:
                print(f"{e['start']} - {e['end']}: {e['summary']}")
                if e['location']:
                    print(f"  Location: {e['location']}")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_create(args):
    """Create a new event."""
    service = get_service()

    try:
        start_dt = parse_datetime(args.when)
        duration = args.duration or 60
        end_dt = start_dt + timedelta(minutes=duration)

        event = {
            'summary': args.title,
            'start': {'dateTime': start_dt.isoformat(), 'timeZone': 'America/Chicago'},
            'end': {'dateTime': end_dt.isoformat(), 'timeZone': 'America/Chicago'},
        }

        if args.location:
            event['location'] = args.location

        if args.description:
            event['description'] = args.description

        if args.attendees:
            event['attendees'] = [{'email': e.strip()} for e in args.attendees.split(',')]

        result = service.events().insert(calendarId='primary', body=event).execute()

        print(f"Event created!")
        print(f"  ID: {result['id']}")
        print(f"  Link: {result.get('htmlLink', '')}")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_update(args):
    """Update an existing event."""
    service = get_service()

    try:
        # Get existing event
        event = service.events().get(calendarId='primary', eventId=args.event_id).execute()

        if args.title:
            event['summary'] = args.title

        if args.when:
            start_dt = parse_datetime(args.when)
            # Keep same duration
            old_start = datetime.fromisoformat(event['start']['dateTime'].replace('Z', '+00:00'))
            old_end = datetime.fromisoformat(event['end']['dateTime'].replace('Z', '+00:00'))
            duration = old_end - old_start
            end_dt = start_dt + duration

            event['start'] = {'dateTime': start_dt.isoformat(), 'timeZone': 'America/Chicago'}
            event['end'] = {'dateTime': end_dt.isoformat(), 'timeZone': 'America/Chicago'}

        if args.location:
            event['location'] = args.location

        if args.description:
            event['description'] = args.description

        result = service.events().update(calendarId='primary', eventId=args.event_id, body=event).execute()

        print(f"Event updated!")
        print(f"  Link: {result.get('htmlLink', '')}")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_delete(args):
    """Delete an event."""
    service = get_service()

    try:
        service.events().delete(calendarId='primary', eventId=args.event_id).execute()
        print(f"Event deleted: {args.event_id}")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_freebusy(args):
    """Show free/busy status for a date."""
    service = get_service()

    try:
        date = parse_datetime(args.date)
        start = date.replace(hour=0, minute=0, second=0, microsecond=0)
        end = start + timedelta(days=1)

        body = {
            "timeMin": start.isoformat() + 'Z',
            "timeMax": end.isoformat() + 'Z',
            "items": [{"id": "primary"}]
        }

        result = service.freebusy().query(body=body).execute()
        busy_times = result['calendars']['primary']['busy']

        if args.json:
            print(json.dumps(busy_times, indent=2))
        else:
            print(f"=== Busy times on {date.strftime('%Y-%m-%d')} ===\n")
            if not busy_times:
                print("All day free!")
            else:
                for slot in busy_times:
                    start_time = datetime.fromisoformat(slot['start'].replace('Z', '+00:00'))
                    end_time = datetime.fromisoformat(slot['end'].replace('Z', '+00:00'))
                    print(f"  {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}: Busy")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_calendars(args):
    """List all calendars."""
    service = get_service()

    try:
        calendars = service.calendarList().list().execute()

        if args.json:
            print(json.dumps(calendars.get('items', []), indent=2))
        else:
            print("Calendars:")
            for cal in calendars.get('items', []):
                primary = " (primary)" if cal.get('primary') else ""
                print(f"  {cal['summary']}{primary}")
                print(f"    ID: {cal['id']}")

    except HttpError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description='Google Calendar CLI',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument('--json', action='store_true', help='Output as JSON')

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # auth
    subparsers.add_parser('auth', help='Authenticate with Google')

    # today
    subparsers.add_parser('today', help="Show today's events")

    # week
    subparsers.add_parser('week', help="Show this week's events")

    # list
    list_parser = subparsers.add_parser('list', help='List events in range')
    list_parser.add_argument('--from', dest='start', required=True, help='Start date')
    list_parser.add_argument('--to', dest='end', help='End date')

    # create
    create_parser = subparsers.add_parser('create', help='Create event')
    create_parser.add_argument('title', help='Event title')
    create_parser.add_argument('--when', '-w', required=True, help='Start time')
    create_parser.add_argument('--duration', '-d', type=int, help='Duration in minutes (default: 60)')
    create_parser.add_argument('--location', '-l', help='Location')
    create_parser.add_argument('--description', help='Description')
    create_parser.add_argument('--attendees', '-a', help='Comma-separated attendee emails')

    # update
    update_parser = subparsers.add_parser('update', help='Update event')
    update_parser.add_argument('event_id', help='Event ID')
    update_parser.add_argument('--title', '-t', help='New title')
    update_parser.add_argument('--when', '-w', help='New start time')
    update_parser.add_argument('--location', '-l', help='New location')
    update_parser.add_argument('--description', help='New description')

    # delete
    delete_parser = subparsers.add_parser('delete', help='Delete event')
    delete_parser.add_argument('event_id', help='Event ID')

    # freebusy
    freebusy_parser = subparsers.add_parser('freebusy', help='Show free/busy for date')
    freebusy_parser.add_argument('date', help='Date to check')

    # calendars
    subparsers.add_parser('calendars', help='List all calendars')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    commands = {
        'auth': cmd_auth,
        'today': cmd_today,
        'week': cmd_week,
        'list': cmd_list,
        'create': cmd_create,
        'update': cmd_update,
        'delete': cmd_delete,
        'freebusy': cmd_freebusy,
        'calendars': cmd_calendars,
    }

    if args.command in commands:
        commands[args.command](args)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
